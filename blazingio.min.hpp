// DO NOT REMOVE THIS MESSAGE. The mess that follows is a compressed build of
// https://github.com/purplesyringa/blazingio. Refer to the repository for
// a human-readable version and documentation.
// Config options: AVX2 LUT CHAR_WITH_SIGN_IS_GLYPH BITSET FLOAT COMPLEX PIPE STDIN_EOF LATE_BINDING CERR
#define L$(x)_mm256_loadu_si256(x)
#define M$(x,...)_mm256_##x##_epi8(__VA_ARGS__)
#define $O operator
#define $r return*this;
#include <array>
#include <bitset>
#include <complex>
#include <cstring>
#include <fcntl.h>
#include <immintrin.h>
#include <limits>
#include <signal.h>
#include <sys/mman.h>
#define $s __attribute__((target("avx2")))
#define E$(x)if(!(x))abort();
namespace $f{using namespace std;struct A{A&$O=(A){$r}};struct B{enum class q:char{};q c;B&$O=(char x){c=q{x};$r}$O char(){return(char)c;}};const long k=68719476736,Z=-1ULL/255;struct $i{off_t M=-1;char*N;B*K;explicit $i(){N=(char*)mmap(0,k,1,2,fileno(tmpfile()),0);E$(N!=(void*)-1)K=(B*)N;}void E(){M=lseek(0,0,2);if(M!=-1){(M+=4095)&=-4096;E$(mmap(N,M,1,18,0,0)!=(void*)-1)E$(madvise(N,M,22)!=-1)}else{size_t w=16384;E$(mmap(N,w,3,32818,-1,0)!=(void*)-1)M=0;ssize_t y;while((y=read(0,N+M,w-M))>0)if((M+=y)>w-4096)E$(mmap(N+w,w,3,32818,-1,0)!=(void*)-1)w*=2;E$(y!=-1)(M+=4095)&=-4096;E$(munmap(N+M+4096,w-M-4096)!=-1)}E$(mmap(N+M,4096,3,50,-1,0)!=(void*)-1)N[M+1]=48;K=(B*)N;}void*tie(nullptr_t){return 0;}void G(){while(0<=*K&&*K<=32)K++;}$s void C(){while((size_t)K%32&&(*K<0||*K>32))K++;if((size_t)K%32)return;auto p=(__m256i*)K;__m256i s,space=M$(set1,32);while(s=M$(cmpeq,space,_mm256_max_epu8(space,*p)),_mm256_testz_si256(s,s))p++;K=(B*)p+__builtin_ctz(M$(movemask,s));}$s void D(){while((size_t)K%32&&*K!=0&&*K!=13&&*K!=10)K++;if((size_t)K%32)return;auto p=(__m256i*)K;auto t=_mm_set_epi64x(0xff0000ff0000,255);__m256i q,r;while(_mm256_testz_si256(q=M$(cmpgt,M$(set1,16),*p),r=M$(shuffle,_mm256_set_m128i(t,t),*p)))p++;K=(B*)p+__builtin_ctz(M$(movemask,q&r));}template<class T>void H(T&x){while((*K&240)==48)x=x*10+(*K++-48);}template<class T,T=1>void I(T&x){bool l=is_signed_v<T>&&*K==45;K+=l;H(x=0);if(l)x=-x;}template<class T,class=decltype(T{1.})>void I(T&x){bool l=*K==45;K+=l;K+=*K==43;auto d=K;uint64_t n;I(n);int f=20;if(*K==46){auto o=++K;H(n);f+=o-K;}x=n;if(K-d>=19){K=d;x=0;H(x);if(*K==46){K++;H(x);}}if((*K|32)==101){K++;K+=*K==43;int k;I(k);f+=k;}if(0<=f&&f<41){constexpr auto m=[]{array<T,41>m{};T x=1;for(int i=21;i--;){m[40-i]=x;m[i]=1/x;x*=10;}return m;}();x*=m[f];}else{while(f-->20)x*=10;while(++f<20)x*=.1;}if(l)x=-x;}void I(bool&x){x=*K++==49;}void I(char&x){x=*K++;}void I(uint8_t&x){x=*K++;}void I(int8_t&x){x=*K++;}template<class T,int=numeric_limits<T>::radix>$i&$O>>(T&O){G();I(O);$r}$i&$O>>(string&O){G();auto d=K;C();((basic_string<A>&)O).resize(K-d);memcpy(O.data(),d,K-d);$r}template<class T>$i&$O>>(complex<T>&O){G();T w,q{};if(*K==40){K++;I(w);if(*K++==44){G();I(q);K++;}}else{I(w);}O={w,q};$r}template<size_t N>$s $i&$O>>(bitset<N>&O){G();if(N>=4096&&!*this)$r auto i=N;while(i%32)O[--i]=*K++==49;auto p=(__m256i*)K;i/=32;while(i){long a=0x1020304050607;((uint32_t*)&O)[--i]=__bswap_32(M$(movemask,M$(shuffle,L$(p++)<<7,_mm256_set_epi64x(a+Z*24,a+Z*16,a+Z*8,a))));}K=(B*)p;$r}$O bool(){return!!*this;}bool $O!(){return(char*)K>N+M;}};struct $o{char*N;B*K;inline static char V[200];$o(){N=(char*)mmap(0,k,3,16418,-1,0);E$(N!=(void*)-1)K=(B*)N;for(int i=0;i<100;i++){V[i*2]=48+i/10;V[i*2+1]=48+i%10;}}~$o(){ssize_t k=1;while(k>0){iovec v{N,(size_t)K-(size_t)N};N+=(k=vmsplice(1,&v,1,8));}if(k){N++;do{N+=(k=write(1,N,(char*)K-N));}while(k>0);E$(k!=-1)}}$o&$O<<(char O){*K++=O;$r}$o&$O<<(uint8_t O){*K++=O;$r}$o&$O<<(int8_t O){*K++=O;$r}$o&$O<<(bool O){*K++=48+O;$r}template<class T,int S,int U,T h=1>void W(T O,T R){if constexpr(U==1){if(S>=1||O>=h)*K++=48+R;}else if constexpr(U==2){if(S>=2||O>=10*h)*K++=V[R*2];if(S>=1||O>=h)*K++=V[R*2+1];}else{constexpr auto j=[]{int g=1;T Q=10;while((g*=2)<U)Q*=Q;return pair{g/2,Q};}();constexpr int g=j.first;constexpr T Q=j.second;W<T,max(0,S-g),U-g,T(h*Q)>(O,R/Q);W<T,min(S,g),g,h>(O,R%Q);}}template<class T,T=1>$o&$O<<(T O){make_unsigned_t<T>P=O;if(O<0){*K++=45;P=-P;}W<decltype(P),1,array{3,5,10,20}[__builtin_ctz(sizeof(O))]>(P,P);$r}template<class T,class=decltype(T{1.})>$o&$O<<(T O){if(O<0){*K++=45;O=-O;}auto w=[&]{W<uint64_t,12,12>(O*1e12,O*1e12);};if(!O){*K++=48;$r}if(O>=1e16){O*=1e-16;int f=16;while(O>=1){O*=.1;f++;}*K++=48;*K++=46;w();*K++=101;*this<<f;}else if(O>=1){uint64_t X=O;*this<<X;if(O-=X){*K++=46;w();}}else{*K++=48;*K++=46;w();}$r}$o&$O<<(const char*O){K=(B*)stpcpy((char*)K,O);$r}$o&$O<<(const uint8_t*O){*this<<(char*)O;$r}$o&$O<<(const int8_t*O){*this<<(char*)O;$r}$o&$O<<(string_view O){memcpy(K,O.data(),O.size());K+=O.size();$r}template<class T>$o&$O<<(complex<T>O){*this<<'('<<O.real()<<','<<O.imag()<<')';$r}template<size_t N>$s $o&$O<<(const bitset<N>&O){auto i=N;while(i%32)*K++=48+O[--i];auto p=(__m256i*)K;i/=32;auto b=_mm256_set1_epi64x(0x102040810204080);while(i)_mm256_storeu_si256(p++,M$(sub,M$(set1,48),M$(cmpeq,M$(shuffle,_mm256_set1_epi32(((uint32_t*)&O)[--i]),_mm256_set_epi64x(0,Z,Z*2,Z*3))&b,b)));K=(B*)p;$r}$o&$O<<($o&(*Y)($o&)){return Y(*this);}};struct $e{template<class T>$e&$O<<(const T&O){$r}$e&$O<<($e&(*Y)($e&)){return Y(*this);}};}namespace std{$f::$i i$;$f::$o o$;$f::$e e$;$f::$i&getline($f::$i&b,string&O){if(*b.K){auto d=b.K;b.D();((basic_string<$f::A>&)O).resize(b.K-d);memcpy(O.data(),(char*)d,b.K-d);b.K+=*b.K==13;}else{b.K=($f::B*)b.N+b.M;}b.K++;return b;}$f::$o&endl($f::$o&J){return J<<'\n';}$f::$o&flush($f::$o&J){return J;}$f::$e&endl($f::$e&J){return J;}$f::$e&flush($f::$e&J){return J;}}struct E{E(){struct sigaction Z;Z.sa_sigaction=L;sigemptyset(&Z.sa_mask);Z.sa_flags=4;sigaction(SIGBUS,&Z,0);}static void L(int,siginfo_t*a,void*){E$(a->si_addr==std::i$.N&&std::i$.M==-1);std::i$.E();}}t$;
#define cin i$
#define cout o$
#ifdef ONLINE_JUDGE
#define cerr e$
#define clog e$
#endif
// End of blazingio
