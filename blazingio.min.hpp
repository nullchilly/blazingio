// DO NOT REMOVE THIS MESSAGE. The mess that follows is a compressed build of
// https://github.com/purplesyringa/blazingio. Refer to the repository for
// a human-readable version and documentation.
// Config options: AVX2 LUT CHAR_WITH_SIGN_IS_GLYPH BITSET FLOAT COMPLEX SPLICE INTERACTIVE STDIN_EOF CERR
#define L$(x)_mm256_loadu_si256(x)
#define M$(x,...)_mm256_##x##_epi8(__VA_ARGS__)
#define $O operator
#define $r return*this;
#include<array>
#include<bitset>
#include<complex>
#include<cstring>
#include<immintrin.h>
#include<sys/mman.h>
#define $s __attribute__((target("avx2")))
#define $I __attribute__((always_inline))
#define $F Z(),
#define E$(x)if(!(x))abort();
namespace $f{using namespace std;struct A{A&$O=(A){$r}};struct B{enum class q:char{};q c;B&$O=(char x){c=q{x};$r}$O char(){return(char)c;}};const long k=68719476736,Z=-1ULL/255;struct b{std::string&O;};static B C[65536];template<bool w>struct q{off_t M;B*l;B*K;void E(){(M+=4095)&=-4096;char*N=(char*)mmap(0,M+4096,1,2,0,0);E$(N!=(void*)-1)E$(madvise(N,M,22)!=-1)l=(B*)N+M;E$(mmap(l,4096,3,50,-1,0)!=(void*)-1)l[1]=48;K=(B*)N;}void L(){l=K=C+1;M=1;}$I void Z(){if(w&&__builtin_expect(K==l,0)){off_t q=0;B*k=C;asm volatile("syscall":"+a"(q),"+S"(k):"D"(0),"d"(65536):"rcx","r11");E$(q>=0)M=q;K=k;l=K+M;if(!M){C[0]=48;C[1]=0;l=0;}}}template<class T>$I void H(T&x){while($F(*K&240)==48)x=x*10+(*K++-48);}template<class T,T=1>$I void u(T&x){bool l=is_signed_v<T>&&($F*K==45);K+=l;H(x=0);if(l)x=-x;}template<class T,class=decltype(T{1.})>$I void u(T&x){bool l=($F*K==45);K+=l;$F K+=*K==43;uint64_t n=0;int i=0;for(;i<18&&($F*K&240)==48;i++)n=n*10+*K++-48;int f=20;bool o=*K;K+=o;for(;i<18&&($F*K&240)==48;i++){n=n*10+*K++-48;f-=o;}x=n;while(($F*K&240)==48){x=n*10+*K++-48;f-=o;}if(*K==46){K++;o=1;}while(($F*K&240)==48){x=n*10+*K++-48;f-=o;}if((*K|32)==101){K++;$F K+=*K==43;int k;u(k);f+=k;}if(0<=f&&f<41){static constexpr auto m=[]{array<T,41>m{};T x=1;for(int i=21;i--;){m[40-i]=x;m[i]=1/x;x*=10;}return m;}();x*=m[f];}else{while(f-->20)x*=10;while(++f<20)x*=.1;}if(l)x=-x;}$I void u(bool&x){x=$F*K++==49;}$I void u(char&x){x=$F*K++;}$I void u(uint8_t&x){x=$F*K++;}$I void u(int8_t&x){x=$F*K++;}$s void u(string&O){auto d=K;auto p=(__m256i*)K;__m256i s,D=M$(set1,32);while(s=M$(cmpeq,D,_mm256_max_epu8(D,L$(p))),_mm256_testz_si256(s,s))p++;K=(B*)p+__builtin_ctz(M$(movemask,s));((basic_string<A>&)O).resize(K-d);memcpy(O.data(),d,K-d);}template<class T>$I void u(complex<T>&O){T w,q{};if($F*K==40){K++;u(w);if($F*K++==44){*this>>q;K++;}}else{u(w);}O={w,q};}template<size_t N>$s void u(bitset<N>&O){if(N>=4096&&!*this)return;auto i=N;while(i%32)O[--i]=$F*K++==49;auto p=(__m256i*)K;i/=32;while(i){long a=0x1020304050607;((uint32_t*)&O)[--i]=__bswap_32(M$(movemask,M$(shuffle,L$(p++)<<7,_mm256_set_epi64x(a+Z*24,a+Z*16,a+Z*8,a))));}K=(B*)p;}$s void u(b&e){if(*K){auto d=K;auto p=(__m256i*)K;auto t=_mm_set_epi64x(0xff0000ff0000,255);__m256i s,q,r;while(s=L$(p),_mm256_testz_si256(q=M$(cmpgt,M$(set1,16),s),r=M$(shuffle,_mm256_set_m128i(t,t),s)))p++;K=(B*)p+__builtin_ctz(M$(movemask,q&r));((basic_string<A>&)e.O).resize(K-d);memcpy(e.O.data(),(char*)d,K-d);K+=*K==13;}else{K=l;}K++;}template<class T>$I void t(T&O){if(!is_same_v<T,b>)while($F 0<=*K&&*K<=32)K++;u(O);}$O bool(){return!!*this;}bool $O!(){return K>l;}};struct $i{q<0>k;q<1>w;explicit $i(){k.M=lseek(0,0,2);if(k.M==-1)w.L();else k.E();}void*tie(nullptr_t){return 0;}template<class T>$I $i&$O>>(T&O){if(__builtin_expect(k.M==-1,0))w.t(O);else k.t(O);$r}$O bool(){return!!*this;}bool $O!(){if(__builtin_expect(k.M==-1,0))return!w;else return!k;}};struct $o{char*N;B*K;inline static char V[200];$o(){N=(char*)mmap(0,k,3,16418,-1,0);E$(N!=(void*)-1)K=(B*)N;for(int i=0;i<100;i++){V[i*2]=48+i/10;V[i*2+1]=48+i%10;}}~$o(){ssize_t k=1;while(k>0){iovec v{N,(size_t)K-(size_t)N};N+=(k=vmsplice(1,&v,1,8));}if(k){N++;do{N+=(k=write(1,N,(char*)K-N));}while(k>0);E$(k!=-1)}}void F(char O){*K++=O;}void F(uint8_t O){*K++=O;}void F(int8_t O){*K++=O;}void F(bool O){*K++=48+O;}template<class T,int S,int U,T h=1>void W(T O,T R){if constexpr(U==1){if(S>=1||O>=h)*K++=48+R;}else if constexpr(U==2){if(S>=2||O>=10*h)F(V[R*2]);if(S>=1||O>=h)F(V[R*2+1]);}else{constexpr auto j=[]{int g=1;T Q=10;while((g*=2)<U)Q*=Q;return pair{g/2,Q};}();constexpr int g=j.first;constexpr T Q=j.second;W<T,max(0,S-g),U-g,T(h*Q)>(O,R/Q);W<T,min(S,g),g,h>(O,R%Q);}}template<class T,T=1>void F(T O){make_unsigned_t<T>P=O;if(O<0){F('-');P=-P;}W<decltype(P),1,array{3,5,10,20}[__builtin_ctz(sizeof(O))]>(P,P);}template<class T,class=decltype(T{1.})>void F(T O){if(O<0){F('-');O=-O;}auto w=[&]{W<uint64_t,12,12>(O*1e12,O*1e12);};if(!O)return F('0');if(O>=1e16){O*=1e-16;int f=16;while(O>=1){O*=.1;f++;}F("0.");w();F('e');F(f);}else if(O>=1){uint64_t X=O;F(X);if(O-=X){F('.');w();}}else{F("0.");w();}}void F(const char*O){K=(B*)stpcpy((char*)K,O);}void F(const uint8_t*O){F((char*)O);}void F(const int8_t*O){F((char*)O);}void F(string_view O){memcpy(K,O.data(),O.size());K+=O.size();}template<class T>void F(complex<T>O){*this<<'('<<O.real()<<','<<O.imag()<<')';}template<size_t N>$s void F(const bitset<N>&O){auto i=N;while(i%32)*K++=48+O[--i];auto p=(__m256i*)K;i/=32;auto b=_mm256_set1_epi64x(0x102040810204080);while(i)_mm256_storeu_si256(p++,M$(sub,M$(set1,48),M$(cmpeq,M$(shuffle,_mm256_set1_epi32(((uint32_t*)&O)[--i]),_mm256_set_epi64x(0,Z,Z*2,Z*3))&b,b)));K=(B*)p;}template<class T>$o&$O<<(const T&O){F(O);$r}$o&$O<<($o&(*Y)($o&)){return Y(*this);}};struct $e{template<class T>$e&$O<<(const T&O){$r}$e&$O<<($e&(*Y)($e&)){return Y(*this);}};}namespace std{$f::$i i$;$f::$o o$;$f::$e e$;$f::$i&getline($f::$i&J,string&O){$f::b e{O};return J>>e;}$f::$o&endl($f::$o&J){return J<<'\n';}$f::$o&flush($f::$o&J){return J;}$f::$e&endl($f::$e&J){return J;}$f::$e&flush($f::$e&J){return J;}}
#define cin i$
#define cout o$
#ifdef ONLINE_JUDGE
#define cerr e$
#define clog e$
#endif
// End of blazingio
